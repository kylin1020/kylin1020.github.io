---
title: des算法理解及代码实现
date: 2024-02-17 10:52:29
tags:
  - 算法
  - DES算法
---
### DES算法介绍
DES（Data Encrytion Standard）算法是由IBM在上世纪70年代开发的一种分组加密算法.

### 加密流程
明文和密钥的长度都是64位，其中密钥每隔8位被设置为奇偶校验位，不参与实际加密流程，因此密钥长度为56位。
分为以下几个步骤:
1. 将明文M进行初始置换IP得到M'
2. 根据密钥生成16组子密钥Ki
3. 进行16次迭代过程得到密文C
4. 将密文C进行逆置换IP-1得到最终密文

流程图:
![DES加密流程](images/des1.png)

#### 初始置换
将原始明文M根据IP置换表进行初始置换，得到M'.  
IP置换表如下:
```text
58, 50, 42, 34, 26, 18, 10, 2,
60, 52, 44, 36, 28, 20, 12, 4,
62, 54, 46, 38, 30, 22, 14, 6,
64, 56, 48, 40, 32, 24, 16, 8,
57, 49, 41, 33, 25, 17, 9,  1,
59, 51, 43, 35, 27, 19, 11, 3,
61, 53, 45, 37, 29, 21, 13, 5,
63, 55, 47, 39, 31, 23, 15, 7
```

置换表中的数值表示该位在原始明文中的位置，例如58表示第一个数值取原始明文的第58位。

示例代码：
```c
// IP置换表
int IP[64] = {
        58, 50, 42, 34, 26, 18, 10, 2,
        60, 52, 44, 36, 28, 20, 12, 4,
        62, 54, 46, 38, 30, 22, 14, 6,
        64, 56, 48, 40, 32, 24, 16, 8,
        57, 49, 41, 33, 25, 17, 9,  1,
        59, 51, 43, 35, 27, 19, 11, 3,
        61, 53, 45, 37, 29, 21, 13, 5,
        63, 55, 47, 39, 31, 23, 15, 7
};

// 按照置换表规则置换布尔数组
void permutation(const bool* bits, bool *output, const int* table, int length) {
    for (int i = 0; i < length; i++) {
        // 下标从0开始
        output[i] = bits[table[i] - 1];
    }
}

void encrypt_block(const char* plaintext, const char* key, bool* result) {

    // 其余代码...

    // IP置换
    bool plaintext_ip_block[64];
    permutation(plaintext_bits, plaintext_ip_block, IP, 64);
}
```

#### 生成子密钥
大致流程图如下:
![DES生成子密钥](images/des子密钥生成.png)

PC-1置换表如下:
```text
57, 49, 41, 33, 25, 17, 9,
 1, 58, 50, 42, 34, 26, 18,
10,  2, 59, 51, 43, 35, 27,
19, 11,  3, 60, 52, 44, 36,
63, 55, 47, 39, 31, 23, 15,
 7, 62, 54, 46, 38, 30, 22,
14,  6, 61, 53, 45, 37, 29,
21, 13,  5, 28, 20, 12,  4
```

将密钥K进行根据PC-1置换表进行置换, 得到56位的密钥K'.将K'分为两部分，前28位为C0，后28位为D0。分别将C0和D0进行循环左移指定次数， 得到C1和D1. 然后将C1和D1合并后进行根据PC-2置换表进行置换， 得到48位子密钥K1. 接着对C1和D1进行循环左移指定次数， 得到C2和D2. 然后将C2和D2合并后进行置换PC-2， 得到48位子密钥K2.如此循环16次得到Kn(16个子密钥)。  
其中每轮循环左移查表为:
```text
1 1 2 2 2 2 2 2 1 2 2 2 2 2 2 1
```
即第1, 2, 9, 16循环左移一次，其余循环左移两次。

PC-2置换表如下:
```text
14, 17, 11, 24,  1,  5,
 3, 28, 15,  6, 21, 10,
23, 19, 12,  4, 26,  8,
16,  7, 27, 20, 13,  2,
41, 52, 31, 37, 47, 55,
30, 40, 51, 45, 33, 48,
44, 49, 39, 56, 34, 53,
46, 42, 50, 36, 29, 32
```
与该置换表进行置换之后去除了9， 18， 22， 25， 35， 38， 43， 54这几个位置的值，将56位的密钥变为了48位。  
生成子密钥的代码示例如下:
```c
// 循环左移指定次数
void left_shift(bool* bits, int bit_length,  int num) {
    for (int i = 0; i < num; i++) {
        bool tmp = bits[0];
        for (int j = 0; j < bit_length - 1; j++) {
            bits[j] = bits[j + 1];
        }
        bits[bit_length - 1] = tmp;
    }
}

void generate_sub_keys(bool* keys, bool sub_keys[16][48]) {

    // PC-1置换
    bool pc_1_bits[56];
    permutation(keys, pc_1_bits, PC_1, 56);


    // 分为两组
    bool left[28];
    bool right[28];

    for (int i = 0; i < 28; i++) {
        left[i] = pc_1_bits[i];
        right[i] = pc_1_bits[i + 28];
    }

    // 生成16个子密钥
    for (int i = 0; i < 16; i++) {
        // 循环左移
        int times = LEFT_SHIFT[i];
        left_shift(left, 28, times);
        left_shift(right, 28, times);
        bool tmp[56];
        // 拼接
        for (int j = 0; j < 28; j++) {
            tmp[j] = left[j];
            tmp[j + 28] = right[j];
        }
        // PC-2置换
        permutation(tmp, sub_keys[i], PC_2, 48);

    }
}
```

#### 迭代过程
将经过初始置换的密文M'分为两部分, 前32位为L0, 后32位为R0。对R0进行f轮函数运算之后与L0异或，得到R1, 并将R0变为L1, 重复此过程16次。  
其中f轮函数的操作如下:
将32位的R_n经过扩展置换变更为48位, 然后与子密钥K_n进行异或运算得到48位的输出, 将该输出进行S盒替代得到32位输出, 然后经过P盒置换得到32位输出。

##### 迭代过程公式:
```text
L_n = R_(n-1)
R_n = L_(n-1) XOR f(R_(n-1), K_n)
```

##### S盒替代
将48位的输入拆分为8组6位，每组6位进行S盒替代，得到32位输出。
对于每组6位的输入, 取第一位和第6位组成二进制数, 得到对应的十进制行row, 再取第二位, 第三位, 第四位和第五位组成二进制数，得到对应的十进制列col，根据得到
的行和列，从S盒中取出对应的值。

每组S盒有4行16列，对应的值如下表所示:
```text
S1:
{ 14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7 },
{ 0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8 },
{ 4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0 },
{ 15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13 }

S2:
{ 15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10 },
{ 3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5 },
{ 0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15 },
{ 13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9 }

S3:
{ 10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8 },
{ 13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1 },
{ 13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7 },
{ 1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12 }

S4:
{ 7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15 },
{ 13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9 },
{ 10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4 },
{ 3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14 }

S5:
{ 2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9 },
{ 14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6 },
{ 4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14 },
{ 11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3 }

S6:
{ 12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11 },
{ 10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8 },
{ 9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6 },
{ 4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13 }

S7:
{ 4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1 },
{ 13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6 },
{ 1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2 },
{ 6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12 }

S8:
{ 13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7 },
{ 1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2 },
{ 7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8 },
{ 2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11 }
```


轮函数示例代码如下:
```c
// f轮函数
void feistel(bool* right, const bool* sub_key, bool* output) {
    // E置换
    bool right_e[48];
    permutation(right, right_e, E, 48);

    // 与子密钥异或
    for (int i = 0; i < 48; i++) {
        right_e[i] = right_e[i] ^ sub_key[i];
    }

    // S盒替换
    bool Bn[32];
    for (int i = 0; i < 8; i++) {
        int pos = i * 6;
        int row = right_e[pos] * 2 + right_e[pos + 5];
        int col = right_e[pos + 1] * 8 + right_e[pos + 2] * 4 + right_e[pos + 3] * 2 + right_e[pos + 4];
        int value = SBOX[i][row][col];
        Bn[pos] = (bool) (value & 8) >> 3;
        Bn[pos + 1] = (bool) (value & 4) >> 2;
        Bn[pos + 2] = (bool) (value & 2) >> 1;
        Bn[pos + 3] = (bool) value & 1;
    }

    // P置换
    permutation(Bn, output, P, 32);
}

void encrypt_block(const char* plaintext, const char* key, bool* result) {

    // 其余代码...
    
        // IP初始置换
    bool plaintext_ip_block[64];
    permutation(plaintext_bits, plaintext_ip_block, IP, 64);

    bool L[32];
    bool R[32];
    for (int i = 0; i < 32; i++) {
        L[i] = plaintext_ip_block[i];
        R[i] = plaintext_ip_block[i + 32];
    }

    bool output[32];

    // 16轮f轮函数
    for (auto & sub_key : sub_keys) {
        feistel(R, sub_key, output);

        // L_n与F(R_n)异或并将R_n赋值给L_n+1
        for (int j = 0; j < 32; j++) {
            output[j] = output[j] ^ L[j];
            L[j] = R[j];
        }
    }

    // 合并L和R
    bool lr[64];
    for (int i = 0; i < 32; i++) {
        lr[i] = L[i];
        lr[i + 32] = R[i];
    }

    // IP逆置换
    permutation(lr, result, FP, 64);
}
```